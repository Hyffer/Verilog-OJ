problems:
- name: 3-8 Decoder
  description: |- 
    本次实验中，您需要使用 Verilog 描述一个 3-8 译码器。

    3-8 译码器接受一个 3-bit 宽度的输入 x，并产生一个 8-bit 宽度的输出 y。

    详细的情况可以参照波形。
  description_input: 您的模块应该以 decoder 命名，并且接受一个 3-bit 宽度的输入 x。
  description_output: 您的模块应该产生一个 8-bit 宽度的输出 y。
  app_data: |-
    {"signal": [
    {"name": "x", "wave": "========", "data": [0, 1, 2, 3, 4, 5, 6, 7]},
    {"name": "y[0]", "wave": "10......"},
    {"name": "y[1]", "wave": "010....."},
    {"name": "y[2]", "wave": "0.10...."},
    {"name": "y[3]", "wave": "0..10..."},
    {"name": "y[4]", "wave": "0...10.."},
    {"name": "y[5]", "wave": "0....10."},
    {"name": "y[6]", "wave": "0.....10"},
    {"name": "y[7]", "wave": "0......1"}
    ]}
  template_code_file:
    name: template_code.v
    content: |-
      module decoder(
          input [2:0] x,
          output [7:0] y
        );
          // place your code here
      endmodule

  judge_files:
    - name: decoder_ref.v
      content: |-
        module decoder(
            input [2:0] x,
            output reg [7:0] y
        );
            always @ (*) begin
                case (x)
                3'b000: y=8'b0000_0001;
                3'b001: y=8'b0000_0010;
                3'b010: y=8'b0000_0100;
                3'b011: y=8'b0000_1000;
                3'b100: y=8'b0001_0000;
                3'b101: y=8'b0010_0000;
                3'b110: y=8'b0100_0000;
                3'b111: y=8'b1000_0000;
                endcase
            end
        endmodule

  testcases:
  - type: SIM
    grade: 10
    testcase_files:
    - name: wavedump.py
      content: |+
        #!/usr/bin/env python3

        from pyDigitalWaveTools.vcd.parser import VcdParser

        class VcdSignalTraversalError(Exception):
            pass

        class VcdSignalComparationError(Exception):
            pass

        class VcdComparator:
            def find_signal_inst(self, data_obj, signal_path):
                components = signal_path.split("/")
                cur = data_obj
                for i in range(0, len(components) - 1):
                    if cur['name'] != components[i]:
                        raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                            cur['name'], components[i], signal_path))

                    if not 'children' in cur.keys():
                        raise VcdSignalTraversalError("{} have no data k-v pair while traversing {}".format(
                            cur['name'], signal_path))

                    found = False
                    for child in cur['children']:
                        if child['name'] == components[i+1]:
                            found = True
                            cur = child
                            break

                    if not found:
                        raise VcdSignalTraversalError("{} have no children called {} while traversing {}".format(
                            cur['name'], components[i+1], signal_path))

                if cur['name'] != components[-1]:
                    raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                        cur['name'], components[-1], signal_path))

                return cur

            def compare_signals(self, ref, ud):
                # compare width
                if ref['type']['width'] != ud['type']['width']:
                    raise VcdSignalComparationError("Signal {} have different width between ref ({}) and ud ({})".format(
                        ref['name'], ref['type']['width'], ud['type']['width']))

                # No need to compare sigType (reg/wire.. anything else?)

                # signal comparation
                # TODO: support for different types ('b0' with 'b000' or 'd0' or something...)

                # Since value change dump theoretically only generates data when changes
                # so direct diffing should work
                for i, val in enumerate(ref['data']):
                    if ud['data'][i] != val:
                        raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(
                            ref['name'], val[0], val, ud['data'][i]))

            def dump_hierarchy(self, data_obj):
                # TODO: only dump names
                print(data_obj.toJSON())

            def __init__(self, vcd_ref, vcd_ut, signal_names):
                """Initialize signals for comparation
                vcd_ref: the reference vcd file
                vcd_ut: the vcd file under test
                signal_names: the signal for comparation, uses "/" to express hierarchy.
                         and the top module name shall also be included.
                """

                with open(vcd_ref) as vcd_ref_file:
                    vcd = VcdParser()
                    vcd.parse(vcd_ref_file)
                    self.data_ref = vcd.scope.toJson()
                    print(self.data_ref)

                with open(vcd_ut) as vcd_ut_file:
                    vcd_ut = VcdParser()
                    vcd_ut.parse(vcd_ut_file)
                    self.data_ut = vcd_ut.scope.toJson()
                    print(self.data_ut)

                # find all signals
                self.signals_ref = [self.find_signal_inst(self.data_ref, i) for i in signal_names]
                self.signals_ut = [self.find_signal_inst(self.data_ut, i) for i in signal_names]

            def compare(self):
                try:
                    # compare all signals
                    for i in range(0, len(self.signals_ref)):
                        self.compare_signals(self.signals_ref[i], self.signals_ut[i])
                    return (True, "No error")
                except VcdSignalComparationError as e:
                    return (False, "{}".format(e))

    - name: vcd_main.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():

            from wavedump import VcdComparator
            cmpr = VcdComparator("./out_ref.vcd", "./out_dut.vcd", ['root/testbench/x', 'root/testbench/y'])
            ret, msg = cmpr.compare()
            return (ret, msg)

        ret, msg = main()
        print(msg)
        print("Ret status: {}".format(ret))
        sys.exit(0 if ret is True else 1)
    - name: testbench.v
      content: |2

        module testbench();
            reg [2:0] x;
            wire [7:0] y;
            decoder DUT(x, y);

            // http://www.referencedesigner.com/tutorials/verilog/verilog_62.php
            initial begin
                $dumpfile("out.vcd");
                // This will dump all signal, which may not be useful
                //$dumpvars;

                // dumping only this module
                //$dumpvars(1, testbench);

                // dumping only these variable
                // the first number (level) is actually useless
                $dumpvars(0, x, y);
            end

            integer i;
            initial begin
                for (i = 0; i < 8; i = i + 1) begin
                    #1 x = i;
                end
            end

        endmodule
    - name: main.sh
      content: |-
        #!/bin/bash
        iverilog ./testcase/testbench.v ./problem/decoder_ref.v -o ref_run
        vvp ref_run
        mv out.vcd out_ref.vcd

        iverilog ./testcase/testbench.v ./submit/code.v -o dut_run
        vvp dut_run
        mv out.vcd out_dut.vcd

        python3 ./testcase/vcd_main.py         # This will compare out_ref.vcd and out_dut.vcd

        if [ $? -ne 0 ]; then
          echo "0" > score.txt
        else
          echo "10" > score.txt
        fi

        echo "NONE" > possible_error.txt