problems:
- name: "MUX 2-to-1多路选择器"
  description: "请写一个描述二路选择器的 Verilog module。\n二路选择器的逻辑特点是，当选择器sel为“0”选择x0的值，当选择器sel为“1”时，输出为x1的值。"
  description_input: "输入x0,x1,sel都为1bit"
  description_output: "输出为 out，位宽为 1。\n您应当通过sel来控制 x0 和 x1 的结果"
  app_data: |-
    {"signal": [
      {"name": "sel", "wave": "0...1..."},
      {"name": "x0", "wave": "0.1.0.1."},
      {"name": "x1", "wave":"01010101"},
      {"name": "out", "wave": "0.1.0101"}
    ]}
  judge_files:
  - name: mux_ref.v
    content: |-
      module top_module(
            input sel,
            input x0,
            input x1,
            output reg out
        );
        
        always @(*)
        if(sel)
          out = x1;
        else
          out = x0;

      endmodule
  template_code_file:
    name: template_code.v
    content: |-
      module top_module(
            input sel,
            input x0,
            input x1,
            output reg out
        );
        // Write your code here
      endmodule
  testcases:
  - type: SIM
    grade: 10
    testcase_files:
    - name: wavedump.py
      content: "#!/usr/bin/env python3\n\n\"\"\"\nExample signal:\n\n{\n    'name':\
        \ 'root', \n    'type': {'name': 'struct'}, \n    'children': [\n        {\n\
        \            'name': 'testbench', \n            'type': {'name': 'struct'},\
        \ \n            'children': [\n                {\n                    'name':\
        \ 'x', \n                    'type': {'width': 3, 'name': 'reg'}, \n     \
        \               'data': [\n                        (0, 'bx'), (1, 'b0'), (2,\
        \ 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8,\
        \ 'b111')\n                    ]\n                }, \n                {\n\
        \                    'name': 'y', \n                    'type': {\n      \
        \                  'width': 8, \n                        'name': 'wire'\n\
        \                    }, \n                    'data': [\n                \
        \        (0, 'bx'), (1, 'b1'), (2, 'b10'), (3, 'b100'), (4, 'b1000'), (5,\
        \ 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')\n         \
        \           ]\n                }\n            ]\n        }\n    ]\n}\n\n\"\
        \"\"\n\n\nfrom pyDigitalWaveTools.vcd.parser import VcdParser\n\nclass VcdSignalTraversalError(Exception):\n\
        \    pass\n\nclass VcdSignalComparationError(Exception):\n    pass\n\ndef\
        \ find_signal_inst(data_obj, signal_path):\n    components = signal_path.split(\"\
        /\")\n    cur = data_obj\n    for i in range(0, len(components) - 1):\n  \
        \      if cur['name'] != components[i]:\n            raise VcdSignalTraversalError(\"\
        {} mismatch with {} while traversing {}\".format(\n                cur['name'],\
        \ components[i], signal_path))\n\n        if not 'children' in cur.keys():\n\
        \            raise VcdSignalTraversalError(\"{} have no data k-v pair while\
        \ traversing {}\".format(\n                cur['name'], signal_path))\n\n\
        \        found = False\n        for child in cur['children']:\n          \
        \  if child['name'] == components[i+1]:\n                found = True\n  \
        \              cur = child\n                break\n\n        if not found:\n\
        \            raise VcdSignalTraversalError(\"{} have no children called {}\
        \ while traversing {}\".format(\n                cur['name'], components[i+1],\
        \ signal_path))\n\n    if cur['name'] != components[-1]:\n        raise VcdSignalTraversalError(\"\
        {} mismatch with {} while traversing {}\".format(\n            cur['name'],\
        \ components[-1], signal_path))\n\n    return cur\n\nclass VcdComparator:\n\
        \n    def compare_signals(self, ref, ud):\n        # compare width\n     \
        \   if ref['type']['width'] != ud['type']['width']:\n            raise VcdSignalComparationError(\"\
        Signal {} have different width between ref ({}) and ud ({})\".format(\n  \
        \              ref['name'], ref['type']['width'], ud['type']['width']))\n\n\
        \        # No need to compare sigType (reg/wire.. anything else?)\n\n    \
        \    # signal comparation\n        # TODO: support for different types ('b0'\
        \ with 'b000' or 'd0' or something...)\n        \n        # Since value change\
        \ dump theoretically only generates data when changes\n        # so direct\
        \ diffing should work\n        for i, val in enumerate(ref['data']):\n   \
        \         if ud['data'][i] != val:\n                raise VcdSignalComparationError(\"\
        Signal {} have difference on time {} (ref={}, ud={})\".format(\n         \
        \           ref['name'], val[0], val, ud['data'][i]))\n\n    def dump_hierarchy(self,\
        \ data_obj):\n        # TODO: only dump names\n        print(data_obj.toJSON())\n\
        \n    def __init__(self, vcd_ref, vcd_ut, signal_names):\n        \"\"\"Initialize\
        \ signals for comparation\n        vcd_ref: the reference vcd file\n     \
        \   vcd_ut: the vcd file under test\n        signal_names: the signal for\
        \ comparation, uses \"/\" to express hierarchy.\n                and the top\
        \ module name shall also be included.\n        \"\"\"\n\n        with open(vcd_ref)\
        \ as vcd_ref_file:\n            vcd = VcdParser()\n            vcd.parse(vcd_ref_file)\n\
        \            self.data_ref = vcd.scope.toJson()\n            print(self.data_ref)\n\
        \n        with open(vcd_ut) as vcd_ut_file:\n            vcd_ut = VcdParser()\n\
        \            vcd_ut.parse(vcd_ut_file)\n            self.data_ut = vcd_ut.scope.toJson()\n\
        \            print(self.data_ut)\n\n        # find all signals\n        self.signals_ref\
        \ = [find_signal_inst(self.data_ref, i) for i in signal_names]\n        self.signals_ut\
        \ = [find_signal_inst(self.data_ut, i) for i in signal_names]\n\n    def compare(self):\n\
        \        try:\n            # compare all signals\n            for i in range(0,\
        \ len(self.signals_ref)):\n                self.compare_signals(self.signals_ref[i],\
        \ self.signals_ut[i])\n            return (True, \"No error\")\n        except\
        \ VcdSignalComparationError as e:\n            return (False, \"{}\".format(e))\n\
        \nimport json\n\nclass VcdSignalValueParseError(Exception):\n    pass\n\n\
        class VcdConverter:\n\n    def __init__(self, data_vcd):\n        self.output\
        \ = {'signal': []}\n        self.data_vcd = data_vcd\n\n    def emitWaveDict(self):\n\
        \        return self.output\n\n    def mergeWaveDict(self, wdict):\n     \
        \   self.output['signal'] += wdict['signal']\n\n    def emitWaveJson(self):\n\
        \        return json.dumps(self.output)\n\n    def parseValue(self, val_str):\n\
        \        \"\"\" Note: b111xx1 -> x \"\"\"\n        if val_str[0] == \"b\"\
        :\n            if val_str.find(\"x\") != -1:\n                return \"x\"\
        \n            return int(val_str[1:], base=2)\n        elif len(val_str) ==\
        \ 1:\n            if val_str[0] == \"x\":\n                return \"x\"\n\
        \            else:\n                return int(val_str, base=2)\n        else:\n\
        \            raise VcdSignalValueParseError(\"Unknown value type\")\n\n  \
        \  def toBinRepr(self, val, width):\n        if val == 'x':\n            return\
        \ 'x' * width\n\n        striped = bin(val)[2:]\n        assert(width >= len(striped))\n\
        \        return \"0\" * (width - len(striped)) + striped\n\n    def addToWaveJsonSeparate(self,\
        \ signal_names, prefix=\"\"):\n        # find common time_max\n        time_max\
        \ = 0\n        for signal_name in signal_names:\n            sig_inst = find_signal_inst(self.data_vcd,\
        \ signal_name)\n            time_max = max(time_max, sig_inst['data'][-1][0])\n\
        \n        for signal_name in signal_names:\n            sig_jsons = []\n \
        \           sig_inst = find_signal_inst(self.data_vcd, signal_name)\n\n  \
        \          width = sig_inst['type']['width']\n            # decompose\n  \
        \          for i in range(0, width):\n                sig_jsons.append({})\n\
        \                sig_jsons[i]['name'] = prefix + sig_inst['name'] + \"[\"\
        \ + str(i) + \"]\"\n\n            local_time_max = sig_inst['data'][-1][0]\n\
        \            waves = [\"\" for i in range(0, width)]\n            cur_step_ptr\
        \ = 0\n\n            # \"x\" or int or \"SOME..\"\n            cur_wave =\
        \ \"SOMETHING_NEVER_HAPPEN\"\n\n            # TODO: Avoid multiple transitions\
        \ at same timestep\n            for i in range(0, local_time_max + 1):\n \
        \               if sig_inst['data'][cur_step_ptr][0] > i:\n              \
        \      # maintain current value\n                    for i in range(0, width):\n\
        \                        waves[i] += \".\"\n                else:\n      \
        \              new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])\n\
        \                    if new_wave == cur_wave:\n                        waves[i]\
        \ += \".\"\n                    else:\n                        # do bitwise\
        \ comparation\n                        if cur_wave == \"SOMETHING_NEVER_HAPPEN\"\
        :\n                            # new_wave_bin[0] is MSB\n                \
        \            new_wave_bin = self.toBinRepr(new_wave, width)\n            \
        \                for i in range(0, width):\n                             \
        \   waves[i] += new_wave_bin[::-1][i]\n                        else:\n   \
        \                         cur_wave_bin = self.toBinRepr(cur_wave, width)\n\
        \                            new_wave_bin = self.toBinRepr(new_wave, width)\n\
        \n                            for i in range(0, width):\n                \
        \                old = cur_wave_bin[::-1][i]\n                           \
        \     new = new_wave_bin[::-1][i]\n                                if old\
        \ != new:\n                                    waves[i] += new\n         \
        \                       else:\n                                    waves[i]\
        \ += '.'\n\n                        cur_wave = new_wave\n\n              \
        \      cur_step_ptr += 1\n\n            for i in range(local_time_max, time_max\
        \ + 1):\n                for i in range(0, width):\n                    waves[i]\
        \ += \".\"\n\n            for i in range(0, width):\n                sig_jsons[i]['wave']\
        \ = waves[i]\n\n            self.output['signal'] += sig_jsons\n\n    def\
        \ addToWaveJsonAggregated(self, signal_names, prefix=\"\"):\n        \"\"\"\
        \ Aggregated view, which uses '=' on every timeslice. \"\"\"\n        # find\
        \ common time_max\n        time_max = 0\n        for signal_name in signal_names:\n\
        \            sig_inst = find_signal_inst(self.data_vcd, signal_name)\n   \
        \         time_max = max(time_max, sig_inst['data'][-1][0])\n\n        for\
        \ signal_name in signal_names:\n            sig_json = {}\n            sig_inst\
        \ = find_signal_inst(self.data_vcd, signal_name)\n            sig_json['name']\
        \ = prefix + sig_inst['name']\n\n            # [0, time_max]\n           \
        \ local_time_max = sig_inst['data'][-1][0]\n            wave = \"\"\n    \
        \        cur_step_ptr = 0\n            cur_wave = \"SOMETHING_NEVER_HAPPEN\"\
        \n            data = []\n\n            # TODO: Avoid multiple transitions\
        \ at same timestep\n            for i in range(0, local_time_max + 1):\n \
        \               if sig_inst['data'][cur_step_ptr][0] > i:\n              \
        \      # maintain current value\n                    wave += \".\"\n     \
        \           else:\n                    new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])\n\
        \                    if new_wave == cur_wave:\n                        wave\
        \ += \".\"\n                    else:\n                        wave += \"\
        =\"\n                        data.append(new_wave)\n                     \
        \   cur_wave = new_wave\n\n                    cur_step_ptr += 1\n\n     \
        \       for i in range(local_time_max, time_max + 1):\n                wave\
        \ += \".\"\n\n            sig_json['wave'] = wave\n            sig_json['data']\
        \ = data\n\n            self.output['signal'].append(sig_json)\n\n\nif __name__\
        \ == \"__main__\":\n    sample_vcd = {'name': 'root', 'type': {'name': 'struct'},\
        \ 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children':\
        \ [{'name': 'x', 'type': {'width': 3, 'name': 'reg'}, 'data': [(0, 'bx'),\
        \ (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'),\
        \ (7, 'b110'), (8, 'b111')]}, {'name': 'y', 'type': {'width': 8, 'name': 'wire'},\
        \ 'data': [(0, 'bx'), (1, 'b1'), (2, 'b1x'), (3, 'b100'), (4, 'b1000'), (5,\
        \ 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')]}]}]}\n   \
        \ sample_vcd2 = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name':\
        \ 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'a', 'type':\
        \ {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (2, '1'), (3,\
        \ '0'), (4, '1')]}, {'name': 'b', 'type': {'width': 1, 'name': 'reg'}, 'data':\
        \ [(0, 'x'), (1, '0'), (3, '1')]}, {'name': 'out', 'type': {'width': 1, 'name':\
        \ 'wire'}, 'data': [(0, 'x'), (1, '1'), (2, '0'), (4, '1')]}]}]}\n    vc =\
        \ VcdConverter(sample_vcd)\n    vc.addToWaveJsonSeparate(['root/testbench/x',\
        \ 'root/testbench/y'], \"mysig_\")\n    vc.addToWaveJsonAggregated(['root/testbench/x',\
        \ 'root/testbench/y'], \"mysig_\")\n    print(vc.emitWaveJson())\n\n    vc2\
        \ = VcdConverter(sample_vcd2)\n    vc2.addToWaveJsonSeparate(['root/testbench/a',\
        \ 'root/testbench/b', 'root/testbench/out'], \"mysig_\")\n    vc2.addToWaveJsonAggregated(['root/testbench/a',\
        \ 'root/testbench/b', 'root/testbench/out'], \"mysig_\")\n    print(vc2.emitWaveJson())\n\
        \n"
    - name: vcd_main.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():

            from wavedump import VcdComparator
            cmpr = VcdComparator("./out_ref.vcd", "./out_mux.vcd", ['root/testbench/sel', 'root/testbench/x0' ,'root/testbench/x1', 'root/testbench/out'])
            ret, msg = cmpr.compare()
            return (ret, msg)

        ret, msg = main()
        print(msg)
        print("Ret status: {}".format(ret))
        sys.exit(0 if ret is True else 1)
    - name: testbench.v
      content: |2

        module testbench();
            reg sel;
            reg x0;
            reg x1;
            wire out;
            top_module MUX(sel, x0, x1, out);

            // http://www.referencedesigner.com/tutorials/verilog/verilog_62.php
            initial begin
                $dumpfile("out.vcd");
                // This will dump all signal, which may not be useful
                //$dumpvars;

                // dumping only this module
                //$dumpvars(1, testbench);

                // dumping only these variable
                // the first number (level) is actually useless
                $dumpvars(0, sel, x0, x1, out);
            end

            integer i;
            initial begin
                #1 sel = 0; x0 = 0; x1 = 0;
                #1 x0 = 1; x1 = 0;
                #1 x0 = 1; x1 = 1;
                #1 x0 = 0; x1 = 1;
                #1 sel = 1; x0 = 0; x1 = 0;
                #1 x0 = 1; x1 = 0;
                #1 x0 = 1; x1 = 1;
                #1 x0 = 0; x1 = 1;
            end

        endmodule
    - name: vcd_visualize.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():
            from pyDigitalWaveTools.vcd.parser import VcdParser
            from wavedump import VcdConverter

            with open("./out_ref.vcd") as vcd_ref_file:
                vcd = VcdParser()
                vcd.parse(vcd_ref_file)
                data_ref = vcd.scope.toJson()

            with open("./out_mux.vcd") as vcd_dut_file:
                vcd = VcdParser()
                vcd.parse(vcd_dut_file)
                data_dut = vcd.scope.toJson()

            vc_ref = VcdConverter(data_ref)
            vc_ref.addToWaveJsonSeparate(['root/testbench/sel', 'root/testbench/x0', 'root/testbench/x1','root/testbench/out'], "reference_")

            vc_dut = VcdConverter(data_dut)
            vc_dut.addToWaveJsonSeparate(['root/testbench/sel', 'root/testbench/x0', 'root/testbench/x1','root/testbench/out'], "your_")

            vc_ref.mergeWaveDict(vc_dut.emitWaveDict())
            out = vc_ref.emitWaveJson()

            with open("./appdata.txt", "w") as f:
                f.write(out)

        main()
    - name: main.sh
      content: |-
        #!/bin/bash
        iverilog ./testcase/testbench.v ./problem/mux_ref.v -o ref_run
        vvp ref_run
        mv out.vcd out_ref.vcd

        iverilog ./testcase/testbench.v ./submit/code.v -o mux_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        vvp mux_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        mv out.vcd out_mux.vcd

        python3 ./testcase/vcd_main.py         # This will compare out_ref.vcd and out_mux.vcd

        if [ $? -ne 0 ]; then
          echo "0" > score.txt
          echo "WA" > possible_error.txt
        else
          echo "10" > score.txt
          echo "NONE" > possible_error.txt
        fi

        python3 ./testcase/vcd_visualize.py    # This will output app_data.txt